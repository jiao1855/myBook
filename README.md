Imports System.Reflection~Imports System.Runtime.CompilerServices~Imports System.Text.RegularExpressions~~Public Module JsonExtensions~~ <Extension()>~ Public Function ToJson(structurer As ValueType) As String~~ Dim fields = structurer.GetType().GetFields()~ Dim fieldJsonList = New List(Of String)~ Dim arrayFieldValue As Object~ Dim arrayElementJson As String~ Dim arrayElementJsonList As List(Of String)~ Dim fieldValue As String~~ For Each field As FieldInfo In fields~~ If field.FieldType.IsArray Then~ arrayFieldValue = field.GetValue(structurer)~ If arrayFieldValue IsNot Nothing Then~ arrayElementJsonList = New List(Of String)~ For Each arrayElement As ValueType In arrayFieldValue~ arrayElementJson = ToJson(arrayElement)~ arrayElementJsonList.Add(arrayElementJson)~ Next~ fieldJsonList.Add(field.Name + "=[" + String.Join("," + field.Name + ",", arrayElementJsonList) + "]=" + field.Name)~ End If~ ElseIf field.FieldType.IsValueType Then~ If field.FieldType.IsPrimitive Then~ fieldValue = field.GetValue(structurer)~ If Not String.IsNullOrWhiteSpace(fieldValue) Then~ fieldJsonList.Add(field.Name + "=" + fieldValue.ToString().Trim().Trim(vbNullChar))~ End If~ Else~ fieldJsonList.Add(field.Name + "=" + ToJson(field.GetValue(structurer)) + "=" + field.Name)~ End If~ Else~ fieldValue = field.GetValue(structurer)~ If Not String.IsNullOrWhiteSpace(fieldValue) Then~ fieldJsonList.Add(field.Name + "=" + fieldValue.ToString().Trim().Trim(vbNullChar))~ End If~ End If~ Next~ Return "{" + String.Join(",", fieldJsonList) + "}"~ End Function~~ <Extension()>~ Public Function Parse(json As String, t As Type) As ValueType~~ Dim fields = t.GetFields()~ Dim mth As Match~ Dim jsonList As List(Of String)~ Dim constructorInfo = t.GetConstructor({GetType(Boolean)})~ Dim instance As ValueType~ Dim parseMethod As MethodInfo~~ If constructorInfo IsNot Nothing Then~ instance = constructorInfo.Invoke({True})~ Else~ instance = Activator.CreateInstance(t)~ End If~~ Try~ For Each field As FieldInfo In fields~ If field.FieldType.IsArray Then~ mth = Regex.Match(json, field.Name + "=\[(\{.*?\})\]=" + field.Name)~ jsonList = mth.Groups(1).Value.Split({"," + field.Name + ","}, StringSplitOptions.RemoveEmptyEntries).ToList()~ SetArrayFieldValue(field, jsonList, instance)~ ElseIf field.FieldType.IsValueType Then~ If field.FieldType.IsPrimitive Then~ mth = Regex.Match(json, field.Name + "=(.*?)[,|\}]")~ parseMethod = field.FieldType.GetMethod("Parse", {GetType(String)})~ field.SetValue(instance, parseMethod.Invoke(Nothing, {mth.Groups(1).Value}))~ Else~ mth = Regex.Match(json, field.Name + "=(\{.*?\})=" + field.Name)~ field.SetValue(instance, mth.Groups(1).Value.Parse(field.FieldType))~ End If~ Else~ mth = Regex.Match(json, field.Name + "=(.*?)[,|\}]")~ field.SetValue(instance, mth.Groups(1).Value)~ End If~ Next~ Catch ex As Exception~ Throw New Exception("データ解析失敗を修正します!")~ End Try~ Return instance~ End Function~~ Private Sub SetArrayFieldValue(arrayField As FieldInfo, jsonList As List(Of String), instance As ValueType)~~ Dim elementType = arrayField.FieldType.GetElementType~ Dim listType = GetType(List(Of)).MakeGenericType(elementType)~ Dim elementList = Activator.CreateInstance(listType)~ Dim element As ValueType~ Dim addMethod = listType.GetMethod("Add")~ Dim toArrayMethod = listType.GetMethod("ToArray")~~ jsonList.ForEach(Sub(xJson)~ element = xJson.Parse(elementType)~ addMethod.Invoke(elementList, {element})~ End Sub)~ arrayField.SetValue(instance, toArrayMethod.Invoke(elementList, {}))~ End Sub~End Module~~Imports System.IO~Imports System.Reflection~Imports System.Text.RegularExpressions~Imports System.Windows.Forms~~''' <summary>~''' Ini設定ファイル設定項目読み込みユーティリティクラス~''' </summary>~Public Class IniHelper~~ Private Const CstIniNotFound = "設定ファイルが存在しない！"~ Private Const CstDelimiter = ";"~ Private Const CstEqual = "="~ Private Declare Function WritePrivateProfileString Lib "kernel32.dll" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal lpByte As Byte(), ByVal lpFileName As String) As Integer~~ ''' <summary>~ ''' メイン設定ファイル~ ''' </summary>~ Private iniFile As String = Path.Combine(Application.StartupPath, Assembly.GetEntryAssembly().GetName().Name + ".ini")~~ ''' <summary>~ ''' ユーザープロファイル（サブプロファイル）~ ''' </summary>~ Private userIni As String = Path.Combine(Application.StartupPath, Assembly.GetEntryAssembly().GetName().Name + "User.ini")~~ ''' <summary>~ ''' 設定項目をメモリに保存するために使用~ ''' </summary>~ Private theConfDict As Dictionary(Of String, Dictionary(Of String, String)) = New Dictionary(Of String, Dictionary(Of String, String))()~~ ''' <summary>~ ''' すべての設定項目を一度にキャッシュに読み込むかどうか~ ''' </summary>~ Private isReadAllConf As Boolean~~ ''' <summary>~ ''' デフォルトコンストラクタ~ ''' </summary>~ Public Sub New()~ If Not File.Exists(iniFile) Then~ Throw New FileNotFoundException(CstIniNotFound, iniFile)~ End If~ End Sub~~ ''' <summary>~ ''' コンストラクタ~ ''' </summary>~ ''' <param name="isReadAllConf">すべての設定項目を一度にキャッシュに読み込むかどうか</param>~ Public Sub New(isReadAllConf As Boolean)~ Me.New()~ Me.IsReadAllConf = isReadAllConf~ End Sub~~ ''' <summary>~ ''' コンストラクタ~ ''' </summary>~ ''' <param name="iniFile">メイン設定ファイル</param>~ ''' <param name="userIni">ユーザープロファイル（サブプロファイル）</param>~ ''' <param name="isReadAllConf">すべての設定項目を一度にキャッシュに読み込むかどうか</param>~ Public Sub New(iniFile As String, Optional userIni As String = "", Optional isReadAllConf As Boolean = False)~~ If Not File.Exists(iniFile) Then~ Throw New FileNotFoundException(CstIniNotFound, iniFile)~ End If~ Me.iniFile = iniFile~ Me.userIni = userIni~ Me.IsReadAllConf = isReadAllConf~ End Sub~~ ''' <summary>~ ''' セクションとキーに基づくコンフィギュレーション項目の値の取得~ ''' </summary>~ ''' <param name="section">構成セクション</param>~ ''' <param name="key">設定項目キー</param>~ ''' <returns>設定項目の値</returns>~ Public Function GetConfValue(section As String, key As String) As String~~ Dim iniConfDict = GetConfDict(section)~ If iniConfDict.ContainsKey(key) Then~ Return iniConfDict(key)~ Else~ Return String.Empty~ End If~ End Function~~ ''' <summary>~ ''' 指定したキーの値を取得する~ ''' </summary>~ ''' <param name="key">設定項目キー</param>~ ''' <returns>設定項目の値</returns>~ Public Function GetConfValue(key As String) As String~~ Dim lines = File.ReadAllLines(iniFile, Commons.DefEncoding)~ For Each line As String In lines~ If line.Contains(CstEqual) AndAlso key.Equals(line.Substring(0, line.IndexOf(CstEqual))) Then~ Return line.Substring(line.IndexOf(CstEqual) + 1)~ End If~ Next~ Return String.Empty~ End Function~~ Public Shared Function GetConfValue(st As Stream, key As String) As String~ Dim stReader = New StreamReader(st, Commons.DefEncoding)~ Dim line = stReader.ReadLine()~ Dim match As Match~ While Not String.IsNullOrEmpty(line)~ match = Regex.Match(line, key + "=(.+)")~ If match.Success Then~ Return match.Groups(1).Value~ End If~ line = stReader.ReadLine()~ End While~ Return String.Empty~ End Function~~ Public Function SetConfValue(section As String, key As String, value As String, Optional isUsrFile As Boolean = False) As Boolean~~ Dim lpFileName As String~ Dim result As String~~ lpFileName = IIf(isUsrFile, userIni, iniFile)~ result = WritePrivateProfileString(section, key, Commons.DefEncoding.GetBytes(value), lpFileName) '書き込み結果~ Return result <> 0~ End Function~~ ''' <summary>~ ''' IsReadAllConf "に従って、すべてのコンフィギュレーション・アイテムを一度にキャッシュに読み込むか、~ ''' 指定されたセクションのコンフィギュレーション・アイテムだけをキャッシュに読み込むかを決定する。~ ''' </summary>~ ''' <param name="section">構成セクション</param>~ ''' <returns>設定項目辞書コレクション</returns>~ Public Function GetConfDict(section As String) As Dictionary(Of String, String)~~ Dim iniConfDict As Dictionary(Of String, String)~ Dim userIniConfDict As Dictionary(Of String, String)~~ Dim iniAllConfDict As Dictionary(Of String, Dictionary(Of String, String))~ Dim userIniAllConfDict As Dictionary(Of String, Dictionary(Of String, String))~~ If theConfDict.ContainsKey(section) Then~ Return theConfDict(section)~ End If~~ If Not isReadAllConf Then~ iniConfDict = ReadConf(iniFile, section)~ If File.Exists(userIni) Then~ userIniConfDict = ReadConf(userIni, section)~ For Each key As String In userIniConfDict.Keys~ If Not iniConfDict.ContainsKey(key) Then~ iniConfDict.Add(key, userIniConfDict(key))~ Else~ If iniConfDict(key).Contains(CstDelimiter) Then~ iniConfDict(key) = String.Join(CstDelimiter, iniConfDict(key).Split(CstDelimiter).Union(userIniConfDict(key).Split(CstDelimiter)).Distinct())~ Else~ iniConfDict(key) = userIniConfDict(key)~ End If~ End If~ Next~ End If~ theConfDict.Add(section, iniConfDict)~ Return iniConfDict~ Else~ iniAllConfDict = ReadAllConf(iniFile)~ If File.Exists(userIni) Then~ userIniAllConfDict = ReadAllConf(userIni)~ For Each userSec In userIniAllConfDict.Keys~ If iniAllConfDict.ContainsKey(userSec) Then~ For Each key In userIniAllConfDict(userSec).Keys~ If Not iniAllConfDict(userSec).ContainsKey(key) Then~ iniAllConfDict(userSec).Add(key, userIniAllConfDict(userSec)(key))~ Else~ If iniAllConfDict(userSec)(key).Contains(CstDelimiter) Then~ iniAllConfDict(userSec)(key) = String.Join(CstDelimiter, iniAllConfDict(userSec)(key).Split(CstDelimiter).Union(userIniAllConfDict(userSec)(key).Split(CstDelimiter)).Distinct())~ Else~ iniAllConfDict(userSec)(key) = userIniAllConfDict(userSec)(key)~ End If~ End If~ Next~ Else~ iniAllConfDict.Add(userSec, userIniAllConfDict(userSec))~ End If~ Next~ End If~ theConfDict = iniAllConfDict~ Return iniAllConfDict(section)~ End If~ End Function~~ ''' <summary>~ ''' 設定セクションに基づいて、ini設定ファイルから設定項目を辞書コレクションに読み込む~ ''' </summary>~ ''' <param name="iniF">ini設定ファイル</param>~ ''' <param name="section">構成セクション</param>~ ''' <returns>指定されたセクションの設定項目を保持する辞書のコレクション。</returns>~ Private Function ReadConf(iniF As String, section As String) As Dictionary(Of String, String)~~ Dim allLines = File.ReadAllLines(iniF, Commons.DefEncoding)~ Dim lines As List(Of String)~ Dim isSectionStart As Boolean = False~ Dim valueList = New List(Of String)()~ Dim itemDict = New Dictionary(Of String, String)~ Dim key As String~ Dim value As String~~ lines = allLines.Where(Function(x) x.Trim().Length > 0 AndAlso Not x.Trim().StartsWith(CstDelimiter) AndAlso Not x.Trim().StartsWith(":")).Select(Function(x) x.Trim()).ToList()~ For Each line As String In lines~ If Not isSectionStart AndAlso line.Equals("[" + section + "]") Then~ isSectionStart = True~ ElseIf isSectionStart Then~ If line.StartsWith("[") Then~ Exit For~ End If~ If line.Contains(CstEqual) Then~ key = line.Substring(0, line.IndexOf(CstEqual)).Trim()~ value = line.Substring(line.IndexOf(CstEqual) + 1).Trim().Trim("""")~ If itemDict.ContainsKey(key) Then~ itemDict(key) = itemDict(key) + CstDelimiter + value~ Else~ itemDict.Add(key, value)~ End If~ End If~ End If~ Next~ Return itemDict~ End Function~~ ''' <summary>~ ''' Ini ファイルからすべての構成項目を辞書コレクションに読み込む。~ ''' </summary>~ ''' <param name="iniF">ini設定ファイル</param>~ ''' <returns>すべての設定項目を保持する辞書のコレクション</returns>~ Private Function ReadAllConf(iniF As String) As Dictionary(Of String, Dictionary(Of String, String))~~ Dim allLines = File.ReadAllLines(iniF, Commons.DefEncoding)~ Dim lines As List(Of String)~ Dim valueList = New List(Of String)()~ Dim confDict = New Dictionary(Of String, Dictionary(Of String, String))~ Dim key As String~ Dim value As String~ Dim match As Match~ Dim section As String = Nothing~~ lines = allLines.Where(Function(x) x.Trim().Length > 0 AndAlso Not x.Trim().StartsWith(CstDelimiter) AndAlso Not x.Trim().StartsWith(":")).Select(Function(x) x.Trim()).ToList()~ For Each line As String In lines~ match = Regex.Match(line, "^\[(.+)\]$")~ If match.Success Then~ section = match.Groups(1).Value~ If Not confDict.ContainsKey(section) Then~ confDict.Add(section, New Dictionary(Of String, String))~ End If~ Continue For~ End If~ If Not String.IsNullOrEmpty(section) AndAlso line.Contains(CstEqual) Then~ key = line.Substring(0, line.IndexOf(CstEqual)).Trim()~ value = line.Substring(line.IndexOf(CstEqual) + 1).Trim().Trim("""")~ If confDict(section).ContainsKey(key) Then~ confDict(section)(key) = confDict(section)(key) + CstDelimiter + value~ Else~ confDict(section).Add(key, value)~ End If~ End If~ Next~ Return confDict~ End Function~End Class~~~Imports System.IO~Imports System.Windows.Forms~~Public Class ProcessHelper~~ Public Shared Function Start(fileName As String, Optional argrms As String = "", Optional workDir As String = "", Optional outputLog As Boolean = True) As String~~ Dim startInfo = New ProcessStartInfo()~ Dim p = New Process~ Dim output = String.Empty~~ startInfo.WindowStyle = ProcessWindowStyle.Hidden~ If outputLog Then~ startInfo.RedirectStandardOutput = True~ End If~ startInfo.UseShellExecute = False~ startInfo.CreateNoWindow = True~ startInfo.FileName = fileName~~ If Not String.IsNullOrEmpty(workDir) AndAlso Directory.Exists(workDir) Then~ startInfo.WorkingDirectory = workDir~ Else~ startInfo.WorkingDirectory = Application.StartupPath~ End If~~ If Not String.IsNullOrEmpty(argrms) Then~ startInfo.Arguments = argrms~ End If~~ p.StartInfo = startInfo~ p.Start()~ If outputLog Then~ output = p.StandardOutput.ReadToEnd()~ p.StandardOutput.Close()~ End If~ p.Close()~ Return output~ End Function~End Class~~~Friend Function HttpPost(url As String, data As String) As String~~ Dim request As HttpWebRequest~ Dim encoding As Encoding~ Dim postData As Byte()~ Dim myRequestStream As Stream~ Dim response As HttpWebResponse~ Dim myResponseStream As Stream~ Dim myStreamReader As StreamReader~ Dim retString As String~~ If ServicePointManager.ServerCertificateValidationCallback Is Nothing Then~ ServicePointManager.ServerCertificateValidationCallback =~ New RemoteCertificateValidationCallback(Function(sender As Object, certificate As X509Certificate, chain As X509Chain, errors As SslPolicyErrors) True)~ End If~~ request = WebRequest.Create(url)~ request.Method = "POST"~ request.ContentType = "application/x-www-form-urlencoded"~ encoding = Commons.DefEncoding~ If data IsNot Nothing Then~ postData = encoding.GetBytes(data)~ request.ContentLength = postData.Length~ myRequestStream = request.GetRequestStream()~ myRequestStream.Write(postData, 0, postData.Length)~ End If~ response = request.GetResponse()~ myResponseStream = response.GetResponseStream()~ myStreamReader = New StreamReader(myResponseStream, encoding)~ retString = myStreamReader.ReadToEnd()~ myStreamReader.Close()~ myResponseStream.Close()~ Return retString~ End Function
